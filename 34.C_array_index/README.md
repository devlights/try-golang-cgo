# これは何？

cgoを利用して、C言語側で定義されたグローバルな配列を、Go言語側から安全にアクセス・変更するサンプルです。

## 概要

C言語側にアクセサ関数（`get_item`）と設定関数（`mod_item`）を用意することで、Go側からCのグローバル配列を直接操作するのではなく、安全なインターフェースを介してやり取りする方法を示します。

Goのコードは、まずC側で配列を初期化し、その内容を表示します。次に、Go側からCの関数を呼び出して配列の各要素を変更し、再度内容を表示して、値が変更されたことを確認します。

## 詳細説明

### C側の実装 (`import "C"` ブロック内)

- `Item` 構造体と `item_list` 配列
  - `Item`構造体と、そのグローバルな配列 `item_list` を定義しています。
- `init_item_list()` / `disp_item_list()`
  - 配列を初期化、及びC側で内容を表示するための関数です。
- `get_item(index)` 関数
  - **アクセサ関数**: 指定されたインデックスの配列要素へのポインタ (`Item*`) を返します。Go側が配列要素への参照を取得するための主要な手段です。
- `mod_item(item, key, value)` 関数
  - **設定関数**: `Item`へのポインタを受け取り、そのメンバーの値を更新します。これにより、Cのデータ構造の知識をGo側から隠蔽します。

### Go側の実装

- `main()` 関数
  - 「初期化 → 表示 → 変更 → 再表示」という一連の流れを実行します。
- `display()` 関数
  - Cの配列をループ処理します。
  - `item := C.get_item(C.size_t(i))` のように、Cの**アクセサ関数**を呼び出して要素へのポインタを取得します。`C.item_list[i]` のような直接アクセスは行いません。
  - 取得したポインタを介して、要素の値を読み取り表示します。
- `modify()` 関数
  - `C.get_item()` で要素へのポインタを取得します。
  - `C.CString()` を使ってGoの文字列をCの文字列に変換し、`defer C.free()` で解放を予約します。
  - Cの**設定関数** `C.mod_item()` を呼び出し、ポインタと新しい値を渡してC側のデータを変更します。

## 重要なコンセプトとベストプラクティス

### 1. アクセサ/設定関数の利用

このサンプルの最も重要な点は、`C.item_list[i]` のような直接的なメモリアクセスを避け、`get_item` や `mod_item` のようなヘルパー関数を介して操作していることです。

**利点:**
- **カプセル化**: C側のデータ構造（この場合は配列）が将来変更されたとしても、Go側のコードを変更する必要がありません。Cのヘルパー関数を修正するだけで済み、GoとCの間の結合度を下げることができます。
- **安全性**: データへのアクセス方法をC側で一元管理できるため、不正なアクセスや意図しない変更を防ぎやすくなります。

### 2. Cのポインタの取り扱い

Goのコードは、`get_item` から `_Ctype_Item` 型のポインタを受け取ります。Goは、そのポインタが指すメモリの詳細を理解することなく、Cのポインタを保持し、他のC関数（`mod_item`）に渡すことができます。これは `cgo` における相互運用性の基本です。

### 3. `C.CString` のメモリ管理

`C.CString()` は、内部で `malloc` を呼び出してCのメモリ領域に文字列を確保します。このメモリはGoのガベージコレクタの管理対象外です。

そのため、`C.CString()` を呼び出した側が `C.free()` を使って明示的にメモリを解放する責任を負います。`defer C.free()` を呼び出し直後に記述するパターンは、メモリリークを防ぐための最も安全で標準的な方法です。
