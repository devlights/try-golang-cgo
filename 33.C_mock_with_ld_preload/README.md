# LD_PRELOAD を利用したモック

## 概要

本サンプルは、環境変数 `LD_PRELOAD` を利用して、Cで作成された共有ライブラリの関数を、cgoで作成したGoの関数に実行時に差し替える（モックする）方法を示します。

この仕組みを利用することで、既存のCアプリケーションの動作を、コードの再コンパイルなしで動的に変更できます。テストやデバッグ、機能拡張などに応用できます。

## ファイル構成

本サンプルは、3つの主要なディレクトリで構成されています。

- `clib/`: 元となるCの共有ライブラリ (`libclib.so`) です。`c_func` という関数を定義しており、これは引数の和を返します。
- `capp/`: `clib` の `c_func` を呼び出すCアプリケーションです。
- `cgo/`: `clib` と同じ `c_func` という名前の関数をGoで実装した共有ライブラリです。こちらは引数の積を返します。`LD_PRELOAD` によって差し込まれるモックとして機能します。

## LD_PRELOADによるモックの仕組み

`LD_PRELOAD` は、Linuxの動的リンカに特定の共有ライブラリを他のどのライブラリよりも先に読み込むよう指示する環境変数です。

1.  通常、`capp` を実行すると、動的リンカは `capp` が依存する `libclib.so` (オリジナルの `clib` ディレクトリにあるライブラリ) を読み込み、`c_func` を呼び出すと加算 (`10 + 20`) が実行されます。
2.  一方、`LD_PRELOAD` に `cgo` でビルドした共有ライブラリ (`cgo/libclib.so`) のパスを指定して `capp` を実行すると、動的リンカは指定されたライブラリを最優先で読み込みます。
3.  `capp` が `c_func` を呼び出すと、シンボルが衝突するため、先に読み込まれた `cgo` ライブラリの `c_func` が解決されます。結果として、Goで実装された乗算 (`10 * 20`) が実行されます。

このようにして、`capp` アプリケーション自体のコードを変更することなく、`c_func` の振る舞いを差し替えることが可能になります。

## 実行方法

`Taskfile.yml` が用意されているため、`task` コマンドでビルドと実行ができます。

```bash
task
```

上記コマンドは、以下の処理を自動的に行います。

1.  `clib` のビルド (`clib/libclib.so` の生成)
2.  `cgo` モジュールのビルド (`cgo/libclib.so` の生成)
3.  `capp` のビルド (オリジナルの `libclib.so` とリンク)
4.  `capp` の実行 (`LD_PRELOAD` なし)
5.  `capp` の実行 (`LD_PRELOAD` あり)

## 実行結果

```
[1][NO   LD_PRELOAD] c_func: 30
[2][WITH LD_PRELOAD] c_func: 200
```

- 1行目は `LD_PRELOAD` を指定せずに実行した結果です。オリジナルの `clib` の `c_func` (加算) が呼ばれ、`10 + 20 = 30` となります。
- 2行目は `LD_PRELOAD` を指定して実行した結果です。`cgo` で実装したモックの `c_func` (乗算) が呼ばれ、`10 * 20 = 200` となります。
